#include <types.h>
#include <lib.h>
#include <synchprobs.h>
#include <synch.h>
#include <opt-A1.h>

/*
 this implementation is a hack and heavily depends on the values of Direction
*/

static struct lock *intersectionLock;
static struct cv *intersectionCv;

// keep track of waiting cars by origin
static int icnt[4][4] = {{0}};

typedef struct 
{
	Direction origin;
	Direction destination;
} Car;

#ifndef SANITY 
static int right[4] = {west, north, east, south};
static int opposite[4] = {south, west, north, east};

// should I make an inlined implementation instead?
static bool
may_crash(Direction origin, Direction destination)
{
  Direction righto = right[origin];
  Direction rightd = right[destination];
  Direction oppo = opposite[origin];
  Direction oppd = opposite[destination];
  if (destination == righto)
  {
    return icnt[oppo][destination] || icnt[oppd][destination] ; 
  } 
  else if (destination == oppo) 
  {
    return icnt[rightd][righto] || icnt[rightd][destination] || 
      icnt[destination][righto] ||
      icnt[righto][origin] || icnt[righto][destination] || icnt[righto][rightd]; 
  }
  else
  {
    return icnt[destination][oppo] || icnt[destination][oppd] ||
      icnt[oppo][origin] || icnt[oppo][destination] || icnt[oppo][oppd] ||
      icnt[oppd][origin] || icnt[oppd][destination];
  }
}
#else
/*
   some crazy optimization of the previous implementation of may_crash
   generated by macro
*/
static inline bool
may_crash(Direction origin, Direction destination)
{
    return ((origin == north && destination == west) && (icnt[south][west] || icnt[east][west])) || ((origin == west && destination == south) && (icnt[east][south] || icnt[north][south])) || ((origin == south && destination == east) && (icnt[north][east] || icnt[west][east])) || ((origin == east && destination == north) && (icnt[west][north] || icnt[south][north])) ||
    ((origin == north && destination == east) && ( icnt[east][south] || icnt[east][west] || icnt[south][north] || icnt[south][east] || icnt[south][west] || icnt[west][north] || icnt[west][east])) || ((origin == east && destination == south) && ( icnt[south][west] || icnt[south][north] || icnt[west][east] || icnt[west][south] || icnt[west][north] || icnt[north][east] || icnt[north][south])) || ((origin == south && destination == west) && ( icnt[west][north] || icnt[west][east] || icnt[north][south] || icnt[north][west] || icnt[north][east] || icnt[east][south] || icnt[east][west])) || ((origin == west && destination == north) && ( icnt[north][east] || icnt[north][south] || icnt[east][west] || icnt[east][north] || icnt[east][south] || icnt[south][west] || icnt[south][north])) ||
    ((origin == north && destination == south) && ( icnt[east][west] || icnt[east][south] || icnt[south][west] || icnt[west][north] || icnt[west][south] || icnt[west][east])) || ((origin == east && destination == west) && ( icnt[south][north] || icnt[south][west] || icnt[west][north] || icnt[north][east] || icnt[north][west] || icnt[north][south])) || ((origin == south && destination == north) && ( icnt[west][east] || icnt[west][north] || icnt[north][east] || icnt[east][south] || icnt[east][north] || icnt[east][west])) || ((origin == west && destination == east) && ( icnt[north][south] || icnt[north][east] || icnt[east][south] || icnt[south][west] || icnt[south][east] || icnt[south][north]));
}
#endif



/*
 * The simulation driver will call this function once before starting
 * the simulation
 *
 * You can use it to initialize synchronization and other variables.
 * 
 */
void
intersection_sync_init(void)
{
  /* replace this default implementation with your own implementation */

  intersectionLock = lock_create("intersectionLock");
  if (intersectionLock == NULL) {
    panic("could not create intersection lock");
  }
  intersectionCv = cv_create("intersectionLock");
  if (intersectionCv == NULL) {
    panic("could not create intersection condition variable");
  }
  return;
}

/* 
 * The simulation driver will call this function once after
 * the simulation has finished
 *
 * You can use it to clean up any synchronization and other variables.
 *
 */
void
intersection_sync_cleanup(void)
{
  KASSERT(intersectionLock != NULL);
  lock_destroy(intersectionLock);
  KASSERT(intersectionCv != NULL);
  cv_destroy(intersectionCv);
}


/*
 * The simulation driver will call this function each time a vehicle
 * tries to enter the intersection, before it enters.
 * This function should cause the calling simulation thread 
 * to block until it is OK for the vehicle to enter the intersection.
 *
 * parameters:
 *    * origin: the Direction from which the vehicle is arriving
 *    * destination: the Direction in which the vehicle is trying to go
 *
 * return value: none
 */

void
intersection_before_entry(Direction origin, Direction destination) 
{
  KASSERT(intersectionLock != NULL);
  KASSERT(intersectionCv != NULL);
  

  //critical section
  lock_acquire(intersectionLock);
  while (may_crash(origin, destination)) 
  {
    cv_wait(intersectionCv, intersectionLock);
  } 
  icnt[origin][destination] ++;
  lock_release(intersectionLock);
  // end of critical section
}


/*
 * The simulation driver will call this function each time a vehicle
 * leaves the intersection.
 *
 * parameters:
 *    * origin: the Direction from which the vehicle arrived
 *    * destination: the Direction in which the vehicle is going
 *
 * return value: none
 */

void
intersection_after_exit(Direction origin, Direction destination) 
{
  KASSERT(intersectionLock != NULL);
  KASSERT(intersectionCv != NULL);

  lock_acquire(intersectionLock);
  icnt[origin][destination] --;
  cv_broadcast(intersectionCv, intersectionLock);
  lock_release(intersectionLock);

}

